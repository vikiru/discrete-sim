{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Discrete Simulation Project [Group 26] Docs!","text":""},{"location":"#project-description","title":"Project Description","text":"The manufacturing facility produces different products (P1, P2, P3) using different combinations of raw components (C1, C2, C3). The components are cleaned and repaired by two inspectors before being sent to workstations (W1, W2, W3) that have buffers for storing them. The inspectors may get blocked if the buffers are full. The workstations start assembling products when they have all the required components. Inspector 1 sends component C1 to the workstation with the shortest queue, while Inspector 2 sends components C2 and C3 randomly. To produce the three products, the following combinations of components are used: P1 is made from C1, P2 is made from C1 and C2, and P3 is made from C1 and C3.  <p> This repository showcases my term project for SYSC4005, in which I developed a discrete simulation model of a manufacturing facility based on the given problem statement. The purpose of this simulation study was to identify and evaluate an alternative operating policy that could enhance the system performance. </p>"},{"location":"#project-author","title":"Project Author","text":"<p>This project was completed individually by Visakan Kirubakaran.</p>"},{"location":"alternate_simulator/","title":"Alternate Simulator","text":"<p> The alternate simulator makes use of the simulator to run the original operating policy followed by the four alternative policies in succession. </p> <p> The difference is that the simulation time is changed to t = 50000 from t = 10000 and each operating policy is run 10 times. The results of these simulations are stored within the results folder with sub-folders separating the results of each simulation run for each policy. </p>"},{"location":"input_modeling/","title":"Input Modeling Source Code Reference","text":""},{"location":"input_modeling/#input_modeling.generate_random_mean_time","title":"<code>generate_random_mean_time(filename)</code>","text":"<p>Generate a random exponentially distributed random value based on mean time.</p>"},{"location":"input_modeling/#input_modeling.get_input_data_mean_time","title":"<code>get_input_data_mean_time(filename)</code>","text":"<p>Get the actual mean time value obtained from the input data files</p>"},{"location":"inspector/","title":"Inspector Source Code Reference","text":""},{"location":"inspector/#inspector.Inspector1","title":"<code>Inspector1</code>","text":""},{"location":"inspector/#inspector.Inspector1.__init__","title":"<code>__init__(env, work_station_list, policy_number)</code>","text":"<p>Initialize Inspector1 with default values.</p>"},{"location":"inspector/#inspector.Inspector1.determine_min_buffer","title":"<code>determine_min_buffer()</code>","text":"<p>Inspector 1 will determine the best workstation buffer to send its c1 component to, based on the smallest size of the buffer.Adhering to a priority-based scheduling and finally return that workstation's buffer.</p>"},{"location":"inspector/#inspector.Inspector1.get_name","title":"<code>get_name()</code>","text":"<p>Used to identify Inspector1.</p>"},{"location":"inspector/#inspector.Inspector1.policy_selector","title":"<code>policy_selector()</code>","text":"<p>Allow the inspector to choose its operating policy based on an input policy number. Based on given policy number, the corresponding workstation's buffer is returned.</p>"},{"location":"inspector/#inspector.Inspector1.random_scheduling_equal_probability","title":"<code>random_scheduling_equal_probability()</code>","text":"<p>The third alternative policy to improve the performance of the system, by generating a random number between 0 and 2 and use that number, to return a workstation's buffer from the list of workstations.</p> <p>This alternate policy focuses on giving all workstation's equal probability of getting C1, 33.33% chance for all workstations.</p>"},{"location":"inspector/#inspector.Inspector1.random_scheduling_less_probability_w1","title":"<code>random_scheduling_less_probability_w1()</code>","text":"<p>The first alternative policy to improve the performance of the system, by generating a random number between 1 and 10 and if the number is in a specific range, return that workstation's buffer to place C1 into.</p> <p>This alternate policy focuses on giving workstation 2 and 3 more probability of getting C1 (both have 40% chance, for a total of 80% chance), this means that workstation 1 only has a 20% chance of getting C1.</p>"},{"location":"inspector/#inspector.Inspector1.random_scheduling_more_probability_w1","title":"<code>random_scheduling_more_probability_w1()</code>","text":"<p>The second alternative policy to improve the performance of the system, by generating a random number between 1 and 10 and if the number is in a specific range, return that workstation's buffer to place c1 into.</p> <p>This alternate policy focuses on giving workstation 1 more probability of getting C1 (60% chance) while workstation 2 and 3 only have 20% chance.</p>"},{"location":"inspector/#inspector.Inspector1.reverse_priority_scheduling","title":"<code>reverse_priority_scheduling()</code>","text":"<p>The fourth alternative policy to improve the performance of the system.</p> <p>This policy is essentially the same as the original policy except that instead of w1 having the highest priority, it now has the lowest priority as such, w3 &gt; w2 &gt; w1 is the new order of priority.</p>"},{"location":"inspector/#inspector.Inspector1.run","title":"<code>run()</code>","text":"<p>Main process loop for Inspector1 where it will simulate inspection of components and placing into respective workstations.</p>"},{"location":"inspector/#inspector.Inspector2","title":"<code>Inspector2</code>","text":""},{"location":"inspector/#inspector.Inspector2.__init__","title":"<code>__init__(env, work_station_list)</code>","text":"<p>Initialize Inspector2 with default values.</p>"},{"location":"inspector/#inspector.Inspector2.get_name","title":"<code>get_name()</code>","text":"<p>Used to identify Inspector2.</p>"},{"location":"inspector/#inspector.Inspector2.get_random_component","title":"<code>get_random_component()</code>","text":"<p>Generate a random number between 0 and 1, 0 refers to a component C2 and 1 refers to a component C3.</p>"},{"location":"inspector/#inspector.Inspector2.run","title":"<code>run()</code>","text":"<p>Main process loop for Inspector2 where it will simulate inspection of components and placing into respective workstations.</p>"},{"location":"license/","title":"Acknowledgements and License","text":""},{"location":"license/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Uses NumPy for generating random values based on exponential distributions.</li> <li>Uses SciPy for statistical functions.</li> <li>Uses SimPy to simulate the manufacturing facility.</li> </ul>"},{"location":"license/#license","title":"License","text":"<p>The contents of this repository are licensed under the terms and conditions of the MIT license.</p> <p>MIT \u00a9 2023 Visakan Kirubakaran.</p>"},{"location":"results/","title":"Understanding the Results","text":""},{"location":"results/#folder-descriptions","title":"Folder Descriptions","text":"<p> The data folder contains the input data that is required for the simulation of the manufacturing facility. This data includes the servicing times of the inspectors who check the quality of the components, and the processing times of the workstations that assemble the components into products.  </p> <p> The policy comparison folder contains a text files that compare the performance of the original policy and the four alternative policies that were proposed to improve the efficiency of the facility. Each policy was simulated for a time period of t = 50000 units, which represents the duration of the production cycle.  </p> <p> The results folder contains sub-folders for each policy, where the simulation results are stored as .txt files. Each file contains information such as the number of products produced, the average waiting time of the workstations, and the utilization rate of the workstations. </p>"},{"location":"results/#example-results-file","title":"Example Results File","text":"<pre><code>Starting simulation [1 / 10] and running for time, t = 50000\nResults of Simulation for the Reverse Priority Policy:\nInspector 1 Avg. Inspection time (C1): 10.575921476912242 +/- 19.773488343937714\nInspector 2 Avg. Inspection time (C2): 15.835667543288643 +/- 31.094128215868412\nInspector 2 Avg. Inspection time (C3): 21.34088124702354 +/- 42.678475201986686\nInspector 1 Avg. Blocked time (C1): 10.575921476912242 +/- 19.773488343937714\nInspector 2 Avg. Blocked time (C2): 15.835667543288643 +/- 31.094128215868412\nInspector 2 Avg. Blocked time (C3): 21.34088124702354 +/- 42.678475201986686\nWorkstation 1 Avg. Process time: 4.748336194888908 +/- 9.049655785423548\nWorkstation 2 Avg. Process time: 10.768314794798476 +/- 20.884083311157\nWorkstation 3 Avg. Process time: 8.983340218115243 +/- 16.91454863433984\nWorkstation 1 Avg. Idle time: 25.99831098712895 +/- 101.4478864559243\nWorkstation 2 Avg. Idle time: 28.37159739712838 +/- 81.18074177245032\nWorkstation 3 Avg. Idle time: 27.432906626100785 +/- 65.04508602887152\nTotal P1 produced: 1625\nTotal P2 produced: 1277\nTotal P3 produced: 1373\nAvg. Buffer Occupancy Using Little's Law For W1: 0.8449451070816909\nAvg. Buffer Occupancy Using Little's Law For W2: 0.7246105975226588\nAvg. Buffer Occupancy Using Little's Law For W3: 0.7533076159527275\n</code></pre>"},{"location":"results/#input-data-folder","title":"Input Data Folder","text":"<p>The input data for the folder including average inspection times for each inspector with their respective components and workstation processing times can be found in the data folder.</p>"},{"location":"results/#policy-comparion-folder","title":"Policy Comparion Folder","text":"<p>A comparison of each of the operating policies simulated at a time, t = 50000 units of time can be found here.</p>"},{"location":"results/#result-folders","title":"Result Folders","text":"<ul> <li>Original Policy</li> <li>Random Policy - Equal Probability for C1</li> <li>Random Policy - Less Probability W1</li> <li>Random Policy - More Probability W1</li> <li>Reverse Priority</li> </ul>"},{"location":"setup/","title":"Prerequisites and Setup of the Project","text":""},{"location":"setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python</li> </ul> <p>Specific python package dependencies include the following:</p> <ul> <li>NumPy</li> <li>SciPy</li> <li>SimPy</li> </ul>"},{"location":"setup/#setup-instructions","title":"Setup Instructions","text":"<p>Clone this repository to your local machine.</p> <pre><code>git clone https://github.com/vikiru/discrete-sim.git\n</code></pre> <p>Install all required Python dependencies (NumPy, SciPy, SimPy).</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"simulator/","title":"Simulator Source Code Reference","text":""},{"location":"simulator/#simulator.calculate_confidence_interval","title":"<code>calculate_confidence_interval(data)</code>","text":"<p>Calculate the 95% confidence interval for each list of data passed.</p>"},{"location":"simulator/#simulator.little_law_calc","title":"<code>little_law_calc(throughput, avg_time_in_buffer)</code>","text":"<p>Little's law (l) = throughtput (# of products / unit time) * lead time (workstation idle time).</p>"},{"location":"simulator/#simulator.return_avg_with_ci","title":"<code>return_avg_with_ci(data)</code>","text":"<p>Returns the average of the data along with the confidence interval as a string.</p>"},{"location":"simulator/#simulator.run_simulation","title":"<code>run_simulation(sim_time, policy_num, i)</code>","text":"<p>Run a simulation of the system for given simulation time and policy number. Print the results of the simulation and save the results to their corresponding files.</p>"},{"location":"simulator/#simulator.save_output_to_file","title":"<code>save_output_to_file(output_text, policy_number, i)</code>","text":"<p>Save the results of each simulation run to a text file.</p>"},{"location":"usage/","title":"Running the Simulator","text":"<p> This repository contains two simulators that model the behavior of a manufacturing facility under different operating policies. The original simulator implements the current policy that the facility follows, while the alternate simulator tests the current policy against the alternative policies that I have devised based on various criteria.  </p> <p> The original simulator runs for a fixed time period of t = 10000 units while the alternate simulator runs for a fixed time period of t = 50000 units. Every unique operating policy is repeated 10 times to obtain statistical estimates of the system performance in both simulators. </p> <p>The original simulator can be started as follows:</p> <pre><code>python simulator.py\n</code></pre> <p>The alternate simulator can be started as follows:</p> <pre><code>python alternate_simulator.py\n</code></pre>"},{"location":"workstation/","title":"Workstation Source Code Reference","text":""},{"location":"workstation/#workstation.Workstation1","title":"<code>Workstation1</code>","text":""},{"location":"workstation/#workstation.Workstation1.__init__","title":"<code>__init__(env)</code>","text":"<p>Initialize Workstation1 with default values.</p>"},{"location":"workstation/#workstation.Workstation1.get_name","title":"<code>get_name()</code>","text":"<p>Used to identify Workstation1.</p>"},{"location":"workstation/#workstation.Workstation1.run","title":"<code>run()</code>","text":"<p>Main process loop, Workstation1 will try to get its required components, if it is able to get a component then it moves on to processing the component, updating both the idle and process time lists respectively.</p>"},{"location":"workstation/#workstation.Workstation2","title":"<code>Workstation2</code>","text":""},{"location":"workstation/#workstation.Workstation2.__init__","title":"<code>__init__(env)</code>","text":"<p>Initialize Workstation2 with default values.</p>"},{"location":"workstation/#workstation.Workstation2.get_name","title":"<code>get_name()</code>","text":"<p>Used to identify Workstation2.</p>"},{"location":"workstation/#workstation.Workstation2.run","title":"<code>run()</code>","text":"<p>Main process loop, Workstation2 will try to get its required components, if it is able to get a component then it moves on to processing the component, updating both the idle and process time lists respectively.</p>"},{"location":"workstation/#workstation.Workstation3","title":"<code>Workstation3</code>","text":""},{"location":"workstation/#workstation.Workstation3.__init__","title":"<code>__init__(env)</code>","text":"<p>Initialize Workstation3 with default values.</p>"},{"location":"workstation/#workstation.Workstation3.get_name","title":"<code>get_name()</code>","text":"<p>Used to identify Workstation3.</p>"},{"location":"workstation/#workstation.Workstation3.run","title":"<code>run()</code>","text":"<p>Main process loop, Workstation3 will try to get its required components, if it is able to get a component then it moves on to processing the component, updating both the idle and process time lists respectively.</p>"}]}